-- Разобрался с этим запросом и понял, как работают JSON-функции в SQL. Никогда раньше не использовал
-- их - обычно данные извлекал из базы, а потом в коде собирал в нужный JSON, либо доставал из базы 
-- уже готовый JSON.

-- JSON_ARRAYAGG - берет кучу строк из таблицы и склеивает значения в массив. 
-- Например, если у крепости 5 гномов с ID 101, 102, 103, 104, 105, то эта функция сделает из них 
-- [101, 102, 103, 104, 105]. Удобно, что не нужно потом в коде собирать эти массивы.

-- JSON_OBJECT создает объект с нужными ключами. В нашем случае делает объект related_entities, 
-- где лежат все связанные с крепостью ID. Получается структура, которую можно сразу отдать клиенту 
-- через API.

-- Понравилось, что используются подзапросы, а не LEFT JOIN. Если бы делали LEFT JOIN с несколькими 
-- таблицами одновременно (гномы, ресурсы, мастерские, отряды), то получилось бы много повторов.
-- Например, если у крепости 3 гнома и 2 ресурса, то LEFT JOIN выдал бы 6 строк - каждый 
-- гном появился бы с каждым ресурсом. Для решения этой проблемы пришлось бы использовать 
-- DISTINCT в агрегатных функциях, чтобы убрать дубли. С подзапросами каждый работает отдельно и чисто.

-- Есть пара моментов которые можно было бы поправить. 
-- Первый момент: если у крепости нет каких-то связанных объектов, в результате будет null. 
-- Возможно, лучше было бы пустые массивы возвращать, c по помощью coalesce и JSON_ARRAY.
-- Второй момент: я бы добавил - ORDER BY в подзапросы, чтобы порядок элементов в массивах был
-- предсказуемым.