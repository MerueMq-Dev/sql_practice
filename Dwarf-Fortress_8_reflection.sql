-- В моём запросе я ошибочно использовал поле outcome как булево (TRUE/FALSE), хотя на самом
-- деле это строка, и нужно было явно проверять значение, например 'Favorable'. Из-за этого 
-- подсчёт успешных встреч мог работать неправильно. Также я сортировал элементы в JSON_ARRAYAGG,
-- чтобы сохранить понятный порядок, а в эталонном варианте сортировка не использовалась. Это небольшая
-- деталь, но может быть полезной, особенно если данные потом куда-то выводятся.
-- Я упустил важный момент — не добавил сортировку итоговых строк по убыванию общего успеха 
-- (ORDER BY overall_success_score DESC). Из-за этого в моём варианте результат выглядел просто 
-- по expedition_id, а не в порядке убывания эффективности. Ещё одно отличие — у меня структура
-- построена через множество LEFT JOIN-ов, тогда как в эталонном решении использовались 
-- WITH-блоки с временными таблицами. Такой подход выглядит чище и удобнее для чтения, особенно
-- если нужно пошагово разбираться, что где считается. Разница есть и в подсчёте улучшения навыков.
-- Я просто смотрел разницу между уровнями до и после экспедиции по дате, а в эталонном решении явно
-- соединялись пары «до» и «после» по каждому навыку через JOIN. Этот способ надёжнее, особенно если
-- навык прокачивался несколько раз. Формулы для расчёта общего успеха тоже отличаются. В моём решении я
-- старался нормализовать значения, чтобы учесть разные масштабы. Другой вариант использует более
-- простую линейную формулу с фиксированными весами. Такой подход легче понять и поддерживать.